// Written by Richelle Streater, Summer 2018.
// Modified by Tim Warburton, Spring 2020.


@kernel void eval_RHS_kernel(const int wgcount, const int wgsize,
			     double4* K,
			     const int* idx,
			     const double* Dx, const double* Dy,  const double* Dz,
			     const double* L,  const double* x,   const double* y, const double* z,
			     const double* f,  const double* ghm,
			     const double* p_u,const double* p_v, const double* p_w,
			     const double* gradghm,  double4* F,
			     const double gh0, const int padded_Nnodes, const int padded_Nnbr, const int Nnbr, const int compute_pid_s) {

  for(int wg=0;wg<wgcount;++wg;@outer(0)){
    for(int wgi=0;wgi<wgsize;++wgi;@inner(0)){
      int i = wgi + wgsize*wg; // could also pass wgsize as a compiler var
      
      if (i < padded_Nnodes) {
	
        double4 H;
        double4 rhs;
	
        // Four-vectors represent u,v,w,h components of the state variable matrices
        double4 dH_dx = (double4)(0.0);
        double4 dH_dy = (double4)(0.0);
        double4 dH_dz = (double4)(0.0);
        double4 LH = (double4)(0.0);
	
#pragma unroll
        for (int j = 0; j < Nnbr; j++){
            int dmid = i*(padded_Nnbr) + j; // DM id = padded_Nnbr*i + j
            H = K[idx[dmid]];
        
            // Update sums
            dH_dx += Dx[dmid] * H; // dH_m/d_n = (D^n)_(ij) (H_m)^(ij)
            dH_dy += Dy[dmid] * H;
            dH_dz += Dz[dmid] * H;
            LH += L[dmid] * H;
        }
	
        // Reset to get H at current node (rather than final neighbor)
        H = K[i+compute_pid_s];
        
        // Evaluate RHS of unconstrained momentum equations
        rhs = (H.s0 * dH_dx) + (H.s1 * dH_dy) + (H.s2 * dH_dz);
        rhs.s0 += f[i] * ((y[i] * H.s2) - (z[i] * H.s1)) + dH_dx.s3;
        rhs.s1 += f[i] * ((z[i] * H.s0) - (x[i] * H.s2)) + dH_dy.s3;
        rhs.s2 += f[i] * ((x[i] * H.s1) - (y[i] * H.s0)) + dH_dz.s3;
        rhs *= -1;
	
        // Project momentum equations to confine motion to the surface of the sphere and add hyperviscosity
        // Get indices of x, y, and z components of projection matrices
        int x_id = 3*i;
        int y_id = 3*i + 1;
        int z_id = 3*i + 2;
    
        // Evaluate projections and apply hyperviscosity
        F[i].s0 = (p_u[x_id] * rhs.s0) + (p_u[y_id] * rhs.s1) + (p_u[z_id] * rhs.s2);
        F[i].s1 = (p_v[x_id] * rhs.s0) + (p_v[y_id] * rhs.s1) + (p_v[z_id] * rhs.s2);
        F[i].s2 = (p_w[x_id] * rhs.s0) + (p_w[y_id] * rhs.s1) + (p_w[z_id] * rhs.s2);
    
        // Calculate the RHS of the geopotential equation
        F[i].s3 = rhs.s3 + (H.s0 * gradghm[x_id]) + (H.s1 * gradghm[y_id]) + (H.s2 * gradghm[z_id]) - (H.s3 + gh0 - ghm[i]) * (dH_dx.s0 + dH_dy.s1 + dH_dz.s2);
        F[i] += LH;
      }
    }
  }

}



// can these pointers be declared restrict ?
@kernel void copy_arr_kernel(const int wgcount, const int wgsize,  double* D,  const double* F, const int arr_size) {

  for(int wg=0;wg<wgcount;++wg;@outer(0)){
    for(int wgi=0;wgi<wgsize;++wgi;@inner(0)){
      int i = wgi + wgsize*wg; // could also pass wgsize as a compiler var
      if(i<arr_size){
	D[i] = F[i]; // D = F
      }
    }
  }

}

@kernel void update_D_kernel(const int wgcount, const int wgsize,
			     const double* F,  double* D, const double coefficient, const int Nnodes){

  for(int wg=0;wg<wgcount;++wg;@outer(0)){
    for(int wgi=0;wgi<wgsize;++wgi;@inner(0)){
      int i = wgi + wgsize*wg; // could also pass wgsize as a compiler var
      if(i<4*Nnodes){
	D[i] += coefficient * F[i];  // D = c*F
      }
    }
  }
}

@kernel void eval_K_kernel(const int wgcount, const int wgsize,
			   double* H,  const double* F,  double* K,
			   const double dt, const int Nnodes, const int compute_pid_s){

  for(int wg=0;wg<wgcount;++wg;@outer(0)){
    for(int wgi=0;wgi<wgsize;++wgi;@inner(0)){
      int i = wgi + wgsize*wg; // could also pass wgsize as a compiler var
      
      if (i < Nnodes*4){
	
	K[compute_pid_s*4 + i] =
	  H[compute_pid_s*4 + i] + dt * F[i];        // K = H + (coeff)*dt*F (RK coefficient handled in invocation (RK_ocl.c)
      }
    }
  }

}

@kernel void update_H_kernel(const int wgcount, const int wgsize,
			     double* H, const double dt,  double* D,
			     double* K, const int Nnodes, const int compute_pid_s){

  for(int wg=0;wg<wgcount;++wg;@outer(0)){
    for(int wgi=0;wgi<wgsize;++wgi;@inner(0)){
      int i = wgi + wgsize*wg; // could also pass wgsize as a compiler var
      
      if (i < Nnodes*4){
	H[compute_pid_s*4 + i] += (dt/6.0) * D[i]; // H += dt/6*D (Add all of the RK pieces and multiply by 1/6 per RK-45 algorithm)
	K[compute_pid_s*4 + i] = H[compute_pid_s*4 + i]; // Update to use H in the first round of the next time step w/o updating eval_RHS args
      }
    }
  }
  return;
}

